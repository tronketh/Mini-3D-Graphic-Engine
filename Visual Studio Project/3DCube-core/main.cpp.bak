#include <GL/glew.h>
#include <GLFW/glfw3.h>
#include <vector>
#include <iostream>

GLFWwindow* window;
bool isRunning=false;

void key_callback(GLFWwindow* window, int key, int scancode, int action, int mods);

struct vec3 {
	float x, y, z;
};

struct triangle {
	vec3 p[3];
};

struct mesh {
	std::vector<triangle> triangles;
};


struct mat4x4 {
	float m[4][4] = {0.0f};
};

mesh cube;
mat4x4 matProj;

void MultiplyMatrix(vec3& i, vec3& o, mat4x4 &m) {
	o.x = i.x * m.m[0][0] + i.y * m.m[1][0] + i.z * m.m[2][0] + m.m[3][0];
	o.y = i.x * m.m[0][1] + i.y * m.m[1][1] + i.z * m.m[2][1] + m.m[3][1];
	o.z = i.x * m.m[0][2] + i.y * m.m[1][2] + i.z * m.m[2][2] + m.m[3][2];
	float w = i.x * m.m[0][3] + i.y * m.m[1][3] + i.z * m.m[2][3] + m.m[3][3];
	
	if (w != 0) {
		o.x /= w;
		o.y /= w;
		o.z /= w;
	}
}

void init(const char* title,int width,int height) {
	if (!glfwInit()) {
		std::cerr << "Failed to Initialize" << std::endl;
		return;
	}
	std::cout << "GLFW Initialized" << std::endl;

	glfwWindowHint(GLFW_RESIZABLE, GLFW_FALSE);

	window = glfwCreateWindow(width,height,title,NULL,NULL);

	//Window Center
	GLFWmonitor* monitor= glfwGetPrimaryMonitor();
	if (!monitor)
		return;
	std::cout << "Window Created" << std::endl;
	const GLFWvidmode* mode = glfwGetVideoMode(monitor);
	if (!mode)
		return;

	int monitorX, monitorY;
	glfwGetMonitorPos(monitor, &monitorX, &monitorY);
	glfwSetWindowPos(window,
		monitorX + (mode->width - width) / 2,
		monitorY + (mode->height - height) / 2);
	//Window Center End

	glfwMakeContextCurrent(window);
	glViewport(0, 0, width, height); 
	glfwSetKeyCallback(window, key_callback);

	if (glewInit() != GLEW_OK) {
		std::cerr << "GLEW not Initialized" << std::endl;
		return;
	}
	isRunning = true;
}

void Update() {
	glfwPollEvents();
	glfwSwapBuffers(window);
	if (glfwWindowShouldClose(window) == 1) {
		isRunning = false;
	}
}

void DrawTriangle(triangle &tri, float intensity) {
	//glLineWidth(2.0);
	glColor3f(intensity, 0, 0);
	glBegin(GL_TRIANGLES);
	glVertex2f(tri.p[0].x,tri.p[0].y);
	glVertex2f(tri.p[1].x,tri.p[1].y);
	glVertex2f(tri.p[2].x,tri.p[2].y);
	glEnd();
}

void Draw() {
	float fTheta = 1.0f * glfwGetTime();
	mat4x4 matRotX, matRotZ;
	matRotZ.m[0][0] = cosf(fTheta);
	matRotZ.m[0][1] = sinf(fTheta);
	matRotZ.m[1][0] = -sinf(fTheta);
	matRotZ.m[1][1] = cosf(fTheta);
	matRotZ.m[2][2] = 1;
	matRotZ.m[3][3] = 1;
	
	matRotX.m[0][0] = 1;
	matRotX.m[1][1] = cosf(fTheta * 0.5f);
	matRotX.m[1][2] = sinf(fTheta * 0.5f);
	matRotX.m[2][1] = -sinf(fTheta * 0.5f);
	matRotX.m[2][2] = cosf(fTheta * 0.5f);
	matRotX.m[3][3] = 1;

	for (auto tri : cube.triangles) {
		triangle triProjected, triTranslate,triRotZ,triRotZX,triInitial;

		triInitial = tri;
		/*
		triInitial.p[0].x = tri.p[0].x + 1.3f;
		triInitial.p[1].x = tri.p[1].x + 1.3f;
		triInitial.p[2].x = tri.p[2].x + 1.3f;
		*/

		MultiplyMatrix(triInitial.p[1],triRotZ.p[1],matRotZ);
		MultiplyMatrix(triInitial.p[2],triRotZ.p[2],matRotZ);
		MultiplyMatrix(triInitial.p[0],triRotZ.p[0],matRotZ);

		MultiplyMatrix(triRotZ.p[0], triRotZX.p[0], matRotX);
		MultiplyMatrix(triRotZ.p[1], triRotZX.p[1], matRotX);
		MultiplyMatrix(triRotZ.p[2], triRotZX.p[2], matRotX);

		triangle triFinal=triRotZX;

		triTranslate = triFinal;
		triTranslate.p[0].z = triFinal.p[0].z + 3.0f;
		triTranslate.p[1].z = triFinal.p[1].z + 3.0f;
		triTranslate.p[2].z = triFinal.p[2].z + 3.0f;

		vec3 line1, line2, normal;

		line1.x = triTranslate.p[1].x - triTranslate.p[0].x;
		line1.y = triTranslate.p[1].y - triTranslate.p[0].y;
		line1.z = triTranslate.p[1].z - triTranslate.p[0].z;

		line2.x = triTranslate.p[2].x - triTranslate.p[0].x;
		line2.y = triTranslate.p[2].y - triTranslate.p[0].y;
		line2.z = triTranslate.p[2].z - triTranslate.p[0].z;

		normal.x = line1.y * line2.z - line1.z * line2.y;
		normal.y = line1.z * line2.x - line1.x * line2.z;
		normal.z = line1.x * line2.y - line1.y * line2.x;

		float m = sqrt(normal.x * normal.x + normal.y * normal.y + normal.z * normal.z);
		normal.x /= m;
		normal.y /= m;
		normal.z /= m;

		vec3 vCamera = { 0.0f, 0.0f, 0.0f }, lightSource = { 0.0f, 0.0f, -1.0f };
		float lightMag = sqrt(lightSource.x * lightSource.x + lightSource.y * lightSource.y + lightSource.z * lightSource.z);
		lightSource.x /= lightMag;
		lightSource.y /= lightMag;
		lightSource.z /= lightMag;

		float intensity = normal.x * lightSource.x + normal.y * lightSource.y + normal.z * lightSource.z;

		float Dot = normal.x * (triTranslate.p[0].x - vCamera.x) 
				  + normal.y * (triTranslate.p[0].y - vCamera.y)
			      + normal.z * (triTranslate.p[0].z - vCamera.z);

		if (Dot < 0.0f) {

			MultiplyMatrix(triTranslate.p[0], triProjected.p[0], matProj);
			MultiplyMatrix(triTranslate.p[1], triProjected.p[1], matProj);
			MultiplyMatrix(triTranslate.p[2], triProjected.p[2], matProj);

			DrawTriangle(triProjected,0.5f+(intensity*0.5f));
		}
	}
}

void Quit() {
	glfwDestroyWindow(window);
	glfwTerminate();
	std::cout << "Game Quit" << std::endl;
}

int main()
{
	//Cube
	
	cube.triangles = {		  
	{0.0f, 0.0f, 0.0f,	0.0f, 1.0f, 0.0f, 	1.0f, 1.0f, 0.0f },
	{0.0f, 0.0f, 0.0f,	1.0f, 1.0f, 0.0f, 	1.0f, 0.0f, 0.0f },
			 	 			 		 			 	   
	{1.0f, 0.0f, 0.0f,	1.0f, 1.0f, 0.0f, 	1.0f, 1.0f, 1.0f },
	{1.0f, 0.0f, 0.0f,	1.0f, 1.0f, 1.0f, 	1.0f, 0.0f, 1.0f },
			 	 			 		 			 	   
	{1.0f, 0.0f, 1.0f,	1.0f, 1.0f, 1.0f, 	0.0f, 1.0f, 1.0f },
	{1.0f, 0.0f, 1.0f,	0.0f, 1.0f, 1.0f, 	0.0f, 0.0f, 1.0f },
	
	{0.0f, 0.0f, 1.0f,	0.0f, 1.0f, 1.0f, 	0.0f, 1.0f, 0.0f },
	{0.0f, 0.0f, 1.0f,	0.0f, 1.0f, 0.0f, 	0.0f, 0.0f, 0.0f },

	{0.0f, 1.0f, 0.0f,	0.0f, 1.0f, 1.0f, 	1.0f, 1.0f, 1.0f },
	{0.0f, 1.0f, 0.0f,	1.0f, 1.0f, 1.0f, 	1.0f, 1.0f, 0.0f },

	{1.0f, 0.0f, 1.0f,	0.0f, 0.0f, 1.0f, 	0.0f, 0.0f, 0.0f },
	{1.0f, 0.0f, 1.0f,	0.0f, 0.0f, 0.0f, 	1.0f, 0.0f, 0.0f },
	};

	// Proejction matrix
	float fNear = 0.1f;
	float fFar = 1000.0f;
	float fFov = 90.0f;
	float fAspectRatio = 600.0f / 800.0f;
	float fFovRad = 1.0f / tanf(fFov * 0.5f / 180.0f * 3.14159f);
	
	matProj.m[0][0] = fAspectRatio * fFovRad;
	matProj.m[1][1] = fFovRad;
	matProj.m[2][2] = fFar / (fFar - fNear);
	matProj.m[3][2] = (-fFar * fNear) / (fFar - fNear);
	matProj.m[2][3] = 1.0f;
	matProj.m[3][3] = 0.0f;

	//Main Game
	init("3D Cube",800,600);
	glClearColor(0.2f, 0.3f, 0.8f, 1.0f);
	while (isRunning) {
		glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
		Draw();
		Update();
	}
	Quit();
	return 0;
}

void key_callback(GLFWwindow* window, int key, int scancode, int action, int mods) {
	if (key == GLFW_KEY_ESCAPE && action == GLFW_PRESS)
		glfwSetWindowShouldClose(window, GLFW_TRUE);
}